\documentclass[10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}

%\usepackage{listings}
%\lstset{inputencoding=utf8,extendedchars=false,keepspaces=true,language=C++} 

\usepackage{caption}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{syntax}
\usepackage{bytefield}
\usepackage{multicol}
\usepackage{longtable}



\usepackage{algpseudocode}
\usepackage{graphicx}

\usepackage[dvipsnames,usenames]{color}
\usepackage{hyperref}
\hypersetup{unicode,breaklinks=true}
%\usepackage{tikz}
%\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,petri,calc,shapes.misc,shapes.geometric}
%\usepackage[chapter]{minted}
%\usepackage{ifplatform}

\textheight 24.0cm
\textwidth 16.2cm

\voffset -2cm
\hoffset .0cm
\oddsidemargin 0.5mm
\evensidemargin 0.5mm
\topmargin -0.4mm
\righthyphenmin=2
\hfuzz=12.7pt
\makeatletter
%\renewcommand\section{\@startsection {section}{1}{\z@}%
%                                   {3.5ex \@plus 1ex \@minus .2ex}%
%                                   {2.3ex \@plus.2ex}%
%                                   {\normalfont\Large\bfseries}}
%\renewcommand{\thesection}{\arabic{section}}
\@addtoreset{equation}{section}
\@addtoreset{figure}{section}
\@addtoreset{table}{section}

\newlength{\chaprule}
\newlength{\ATchapskip}
\setlength{\chaprule}{0.4\p@} \setlength{\ATchapskip}{10\p@} \advance \ATchapskip by -1\chaprule
\renewcommand{\@makechapterhead}[1]{%
    \ifdim\chaprule>6\p@ \setlength{\chaprule}{6\p@}\fi
    \vspace*{\ATchapskip}%
    %\noindent\rule{\textwidth}{\chaprule}\par%
    %\vskip 10\p@
    {\parindent \z@ \normalfont \ifnum \c@secnumdepth >\m@ne {\huge\bfseries \@chapapp\space \thechapter.}
        %\par\nobreak
        %\vskip 8\p@
        \fi \interlinepenalty\@M \huge\bfseries #1\par\nobreak \vskip 10\p@
        %\noindent\rule{\textwidth}{\chaprule}\par%
        \vskip\ATchapskip }}

%\@addtoreset{lstlisting}{section}
\makeatother

%\iflinux
%\else
%\ifwindows
%\makeatletter
%\newcommand{\minted@write@detok}[1]{%
%  \immediate\write\FV@OutFile{\detokenize{#1}}}%
%
%\newcommand{\minted@FVB@VerbatimOut}[1]{%
%  \@bsphack
%  \begingroup
%    \FV@UseKeyValues
%    \FV@DefineWhiteSpace
%    \def\FV@Space{\space}%
%    \FV@DefineTabOut
%    %\def\FV@ProcessLine{\immediate\write\FV@OutFile}% %Old, non-Unicode version
%    \let\FV@ProcessLine\minted@write@detok %Patch for Unicode
%    \immediate\openout\FV@OutFile #1\relax
%    \let\FV@FontScanPrep\relax
%%% DG/SR modification begin - May. 18, 1998 (to avoid problems with ligatures)
%    \let\@noligs\relax
%%% DG/SR modification end
%    \FV@Scan}
%    \let\FVB@VerbatimOut\minted@FVB@VerbatimOut
%
%\renewcommand\minted@savecode[1]{
%  \immediate\openout\minted@code\jobname.pyg
%  \immediate\write\minted@code{\expandafter\detokenize\expandafter{#1}}%
%  \immediate\closeout\minted@code}
%\makeatother
%\fi
%\fi


\newcommand{\dom}{\rm dom}
\newcounter{rem}[section]
\renewcommand{\therem}{\thesection.\arabic{rem}}
\newenvironment{Remark}{\par\refstepcounter{rem} \bf Замечание \therem. \sl}{\rm\par}
\renewcommand{\theequation}{\thesection.\arabic{equation}}
\renewcommand{\thefigure}{\thesection.\arabic{figure}}
\renewcommand{\thetable}{\thesection.\arabic{table}}
%\renewcommand{\thelstlisting}{\thesection.\arabic{lstlisting}}
%\renewcommand{\lstlistingname}{Листинг}

\renewcommand{\theenumi}{\arabic{enumi}}
\renewcommand{\labelenumi}{\theenumi)}
\newcommand{\udc}[1]{УДК #1}

\newcounter{lem}[section]
\renewcommand{\thelem}{\thesection.\arabic{lem}}
\newenvironment{Lemma}{\par\refstepcounter{lem}\bf Лемма \thelem. \sl}{\rm\par}

\newcounter{cor}[section]
\renewcommand{\thecor}{\thesection.\arabic{cor}}
\newenvironment{Corrolary}{\par\refstepcounter{cor}\bf Следствие \thecor. \sl}{\rm\par}
\newcounter{theor}[section]
\renewcommand{\thetheor}{\thesection.\arabic{theor}}
\newenvironment{Theorem}{\par\refstepcounter{theor}\bf Теорема \thetheor. \sl}{\rm\par}
%\let \kappa=\ae
\newcommand{\diag}{\mathop{\rm diag}}
\newcommand{\epi}{\mathop{\rm epi}}
\newenvironment{Proof}{\par\noindent\bf Доказательство.\rm}{ \par}

\newcounter{exam}[section]
\renewcommand{\theexam}{\thesection.\arabic{exam}}
\newenvironment{Example}{\par\refstepcounter{exam}\bf Пример \theexam. \sl}{\rm\par}

\newcounter{prob}[section]
\renewcommand{\theprob}{\thesection.\arabic{prob}}
\newenvironment{Problem}{\par\refstepcounter{prob}\bf Задача \theprob. \sl}{\rm\par}

\newcounter{sol}[section]
\renewcommand{\thesol}{\thesection.\arabic{sol}}
\newenvironment{Solution}{\par\refstepcounter{sol}\bf Решение. \rm}{\rm\par}

\newcounter{defin}[section]
\renewcommand{\thedefin}{\thesection.\arabic{defin}}
\newenvironment{Definition}{\par\refstepcounter{defin}\bf Определение \thedefin.\sl}{\rm\par}

\newcounter{answ}[section]
\renewcommand{\theansw}{\thesection.\arabic{answ}}
\newenvironment{Answer}{\par\refstepcounter{answ}\theansw. \rm}{\rm\par}

\newcounter{exerc}[section]
\renewcommand{\theexerc}{\thesection.\arabic{exerc}}
\newenvironment{Exercise}{\par\refstepcounter{exerc}\bf Упражнение \theexerc.\sl}{\rm\par}

\newcounter{algor}[section]
\renewcommand{\thealgor}{\thesection.\arabic{algor}}
\newenvironment{Algorithm}[3]{\par\refstepcounter{algor}{\bf Алгоритм \thealgor. }{\sl #1}\par{\bf Вход: }{\sl #2}\par{\bf Выход: }\sl #3\par{\bf Метод.}\par}{\rm\par}

\newcommand{\ljoq}{<<}
\newcommand{\rjoq}{>>}
\newcommand{\vraisup}{\mathop{\rm vraisup}}
\newcommand{\pr}{\mathop{\rm pr}}
\newcommand{\sgn}{\mathop{\rm sgn}}
\newcommand{\epsclos}{\mathop{\text{$\varepsilon$--замыкание}}}
\newcommand{\move}{\mathop{\text{переход}}}
\newcommand{\closure}{\mathop{\text{ЗАМЫКАНИЕ}}}
\newcommand{\goto}{\mathop{\text{ПЕРЕХОД}}}
\newcommand{\ACTION}{\text{ДЕЙСТВИЕ}}
\newcommand{\GOTO}{\text{ПЕРЕХОД}}
\newcommand{\shift}[1]{\textbf{п}#1}
\newcommand{\reduce}[1]{\textbf{св}#1}
\newcommand{\access}{\textbf{доп}}
%\captiondelim{. }

\captionsetup{labelsep=period}

%\setcounter{page}{3}
%\setcounter{section}{1}


\makeatletter
\def\@seccntformat#1{\csname the#1\endcsname.\quad}
\makeatother

\algrenewcommand\algorithmicwhile{\textbf{пока}}
\algrenewcommand\algorithmicdo{\textbf{ }}
\algrenewcommand\algorithmicend{\textbf{конец}}
\algrenewcommand\algorithmicif{\textbf{если}}
\algrenewcommand\algorithmicthen{\textbf{то}}
\algrenewtext{EndIf}{\textbf{всё}}
\algrenewcommand\algorithmicfor{\textbf{для}}
\algrenewtext{ForAll}{\textbf{для всех }}
\algrenewcommand\algorithmicelse{\textbf{иначе}}
\algrenewtext{ElsIf}{\textbf{инес }}
\algrenewtext{Procedure}{\textbf{алг }}
\algrenewtext{EndProcedure}{\textbf{кон }}

\newcommand{\nad}[2]{\genfrac{}{}{0pt}{0}{#1}{#2}}

\newcommand{\nullable}{\mathop{\textit{зануляется}}}
\newcommand{\firstpos}{\mathop{\textit{первые}}}
\newcommand{\lastpos}{\mathop{\textit{последние}}}
\newcommand{\followpos}{\mathop{\textit{следующие}}}

\newcommand{\myor}{\mathop{\textbf{или}}}

\newcommand{\myand}{\mathop{\textbf{и}}}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}
%\renewcommand{\listingscaption}{Листинг}
%\renewcommand{\listoflistingscaption}{Список листингов}
\begin{document}
\begin{titlepage}
\begin{center}
\vspace*{8cm}

{\bf\Huge
Сообщение о языке программирования Лиса

} \vspace{2.5cm}


\LARGE
\textbf{Сарыкова А.А.}

 \vspace{2.5cm}

{16 марта 2019г.}

\end{center}
\end{titlepage}
\tableofcontents

\newpage

\chapter{Язык}
    \chapter{Лексическая структура}
В данной главе описывается лексическая структура языка.
\section{Обозначения}	
Для описания как лексической структуры, так и для описания синтаксиса используется запись в виде расширенных формул Бэкуса--Наура (РБНФ). В используемом варианте РБНФ  формула состоит из двух частей: первая часть содержит имя определяемого понятия, выделенное зелёным цветом, а затем, после метасимвола \textcolor{Green}{$\to$}, идёт вторая часть, содержащая определение понятия. В этой второй части допускается использование регулярных выражений над терминалами и нетерминалами, а в этих регулярных выражениях допускаются следующие операторы: 
\begin{enumerate}
\item \textcolor{Green}{$|$} --- бинарный инфиксный оператор, означает\ \glqq или\grqq;
\item \textcolor{Green}{$^*$} --- унарный постфиксный оператор, означает\ \glqq может повторяться любое число раз, в том числе ни разу\grqq;
\item \textcolor{Green}{$^+$} --- унарный постфиксный оператор, означает\ \glqq может повторяться любое число раз, но хотя бы один раз\grqq;
\item \textcolor{Green}{$?$} --- унарный постфиксный оператор, означает\ \glqq может присутствовать, а может отсутствовать\grqq;
\item\textcolor{Green}{$( )$} --- эти скобки группируют конструкции.
\end{enumerate}

При этом сначала выполняется то, что в скобках; затем, слева направо, --- унарные операторы; и в конце --- бинарный инфиксный оператор, тоже слева направо.

\section{Кодировка исходного текста программы}
Каждый файл исходного текста должен быть в кодировке UTF-8 (без BOM).		
\section{Ключевые слова}
В языке есть зарезервированные слова, которые не могут использоваться в качестве имён каких--либо модулей, функций, переменных, констант, типов, и компонент типов. Данные зарезервированные слова далее будут называться ключевыми словами. Ниже приведён исчерпывающий список ключевых слов.
\begin{multicols}{4}
\bf

бескон

бз

бз8

бз16

бз32

бз64

бз128

бол

в

вещ

вещ32

вещ64

вещ80

вещ128

возврат

выбор

выдел

выход

глав

для

если

иначе

иначеесли

истина

компл

компл32

компл64

компл80

компл128

конст

логик

логик8

логик16

логик32

логик64

ложь

мал

массив

множество

модуль

ничего

очищ

перем

перечисление

повт

пока

разбор

симв

строка

структ

ссылка

тип

то

фун

чистая

цел

цел8

цел16

цел32

цел64

цел128
\end{multicols}

\section{Идентификаторы}
Идентификатор --- это последовательность букв, десятичных цифр, и знаков подчёркивания, которая должна начинаться либо с буквы, либо со знака подчёркивания. Под буквой понимается любая латинская буква или кириллическая буква. Идентификатор не может совпадать ни с одним ключевым словом.

Примеры идентификаторов: \texttt{крокодил}, \texttt{Гена}, \texttt{_s1024}, \texttt{Баба_Яга}, \texttt{Чебурашка}.

\section{Числа}
\subsection{Целые числа}
Целые числа могут быть двоичными, восьмеричными, шестнадцатиричными, и десятичными. Ниже приведён синтаксис записи целых чисел:

\newcommand{\snotion}[1]{\textcolor{Green}{\syntax{#1}}}
\newcommand{\is}{\textcolor{Green}{$\to$}}
\newcommand{\rbo}{\textcolor{Green}{(}}
\newcommand{\rbc}{\textcolor{Green}{)}}
\newcommand{\sor}{\textcolor{Green}{|}}
\newcommand{\optional}{\textcolor{Green}{?}}
\newcommand{\kleene}{\textcolor{Green}{$^*$} }
\newcommand{\positive}{\textcolor{Green}{$^+$} }

\snotion{двоичное_целое}\is0\rbo b\sor B\rbc\rbo 0\sor 1\rbc\rbo'\optional \rbo 0\sor 1\rbc\rbc \kleene

\snotion{восьмеричное_целое}\is0\rbo o\sor O\rbc\rbo 0\sor 1\sor 2\sor 3\sor 4\sor 5\sor 6\sor 7\rbc\rbo'\optional \rbo 0\sor 1\sor 2\sor 3\sor 4\sor 5\sor 6\sor 7\rbc\rbc \kleene

\snotion{десятичное_целое}\is\rbo 0\sor 1\sor 2\sor 3\sor 4\sor 5\sor 6\sor 7\sor 8\sor 9\rbc\rbo'\optional \rbo 0\sor 1\sor 2\sor 3\sor 4\sor 5\sor 6\sor 7\sor 8\sor 9\rbc\rbc \kleene

\snotion{шестнадцатиричное_целое}\is0\rbo x\sor X\rbc\snotion{шестнадцатиричная_цифра}\rbo'\optional\snotion{шестнадцатиричная_цифра}\rbc\kleene

\snotion{шестнадцатиричная_цифра}\is0\sor 1\sor 2\sor 3\sor 4\sor 5\sor 6\sor 7\sor 8\sor 9\sor A\sor B\sor C\sor D\sor E\sor F\sor a\sor b\sor c\sor d\sor e\sor f


\subsection{Вещественные числа}
Вещественные числа выглядят следующим образом:   

\snotion{вещественное}\is\snotion{целая_часть}\rbo.\snotion{дробная_часть}\rbc\optional\rbo\rbo{E}\sor{e}\rbc\rbo\texttt{+}\sor\texttt{-}\rbc\optional\snotion{порядок}\rbc\optional\snotion{суффикс_точности}\optional

\snotion{целая_часть}\is\snotion{десятичное_целое}

\snotion{дробная_часть}\is\snotion{десятичное_целое}

\snotion{порядок}\is\snotion{десятичное_целое}

\snotion{суффикс_точности}\is f\sor d\sor x\sor q

Необязательный \snotion{суффикс_точности} указывает, какую точность имеет вещественный литерал: одинарную, если указано f; двойную, если указано d; расширенную (т.е. 80 разрядов), если указано x; и четырёхкратную (т.е. в числе 128 разрядов), если указано q. Если не указано никакого суффикса, то вещественный литерал рассматривается как имеющий двойную точность.

\subsection{Комплексные числа}
Поддерживаются только чисто мнимые комплексные литералы. Для этого нужно сразу после записи вещественного литерала записать букву i. При этом точность комплексного литерала --- такая же, как и точность вещественного литерала, идущего перед i. Если же нужно записать комплексное число, у которого и вещественная, и мнимая части не равны нулю, то нужно писать соединять их знаками \texttt{+} или \texttt{-}. Например, если нужно записать комплексное число $-3.876-45.67i$, обе компоненты которого имеют четырёхкратную точность, то нужно писать \texttt{-3.876q-45.67qi}.

\section{Символьные литералы}
Символьный литерал можно задать двумя способами. Во--первых, можно просто заключить нужный символ в одинарные кавычки. Если при этом нужным символом является сам символ одинарной кавычки, то этот символ нужно удвоить. Примеры: \verb|'я'|, \verb|''''|. В первом случае определяется символ, представляющий русскую букву \glqq{я}\grqq, а во втором случае --- символ, представляющий одинарную кавычку. Во--вторых, символьный литерал можно задать кодом соответствующего символа. Для этого нужно записать знак \$, сразу после которого указать код символа, двоичный, восьмеричный, десятичный, или шестнадцатеричный. 

\section{Строковые литералы}
Строковый литерал можно задать тремя способами: либо как цепочку символьных литералов, заданных своими кодами; либо как цепочку символов, заключённых в двойные кавычки (если нужно внутри указать символ двойной кавычки, то его нужно удвоить), либо как чередование того и другого.

Примеры строковых литералов:\\[0.1mm]

\noindent"{}" --- пустая строка\\[0.1mm]

\noindent\texttt{"Хорошо живёт на свете Винни-Пух!"\$13\$10}\\[0.1mm]

\noindent\texttt{"У попа была собака, он её любил.\\
	Она съела кусок мяса, --- он её убил.\\
	В землю закопал и надпись надписал: ..."}\\[0.1mm]

\noindent\texttt{"Привет лунатикам!"\$0}


\section{Знаки операций и разделители}
В языке имеются следующие знаки операций и разделители:        
\begin{center}
	\begin{multicols}{10}
		\tt
		\noindent[
		
		\noindent]
		
		\noindent(\\
		)\\
		<-\\
		->\\
		!\\
		\~{ }\\
		\^{ }\\
		@\\
		.\\
		:\\
		;\\
		==\\
		\#\\
		+\\
		-\\
		*\\
		/\\
		\%\\
		|\\
		\&\\
		<\\
		>\\
		?\\
		\verb|[:|\\ %
		\verb|:]|\\
		(:\\
		:)\\
		::\\
		\{\\
		\}\\
		+|\\
		+{}+\\
		-{}-\\
		+.\\
		-.\\
		*.\\
		/.\\
		\%.\\
		..\\
		?.\\
		<=\\
		>=\\
		!=\\
		**\\
		\^{ }\^{ }\\
		||\\
		\&\&\\
		<{}<\\
		>{}>\\
		\#\#\\
		=\\
		@@\\
		%|:\\
		\~{ }|\\
		\~{ }\&\\
		!||\\
		!\&\&\\
		**.\\
		\#\#\#\\
		+{}+<\\
		-{}-<\\
		+=\\
		-=\\
		*=\\
		/=\\
		\%=\\
		:=\\
		|=\\
		\&=\\
		\^{ }=\\
		||.\\
		\&\&.\\
		+.=\\
		-.=\\
		*.=\\
		/.=\\
		\%.=\\
		||=\\
		\&\&=\\
		\^{ }\^{ }=\\
		**=\\
		<{}<=\\
		>{}>=\\
		%\verb"/\:="\\
		\~{ }|=\\
		\~{ }\&=\\
		!||.\\
		!\&\&.\\
		||.=\\
		\&\&.=\\
		**.=\\
		!||=\\
		!\&\&=\\
		!||.=\\
		\{..\}\\
		!\&\&.=\\
		.|.
	\end{multicols}
\end{center}

\section{Комментарии}
В любом месте программы могут присутствовать комментарии.        
Комментарий может занимать любое число строк исходного текста, а начинается с сочетания \verb|/*| и заканчивается сочетанием \verb|*/|. Кроме того, комментарии могут быть вложенными, без ограничения на уровень вложенности.
Приведём пример:
\begin{verbatim}
т=sin(x)
/* Это комментарий первого уровня вложенности.
/* Это - второго.
/* А это - третьего. */
*/
*/
\end{verbatim}

\chapter{Структура программы}
Структура программы на языке Лиса такова:

\syntax{\noindent\textbf{модуль} \snotion{имя_модуля}\\
	\{\\
	\phantom{привет}\snotion{описание}\kleene\\
	\}%
}

Здесь

\noindent\snotion{имя_модуля} --- идентификатор, являющийся именем данного модуля;

\noindent\snotion{описание} --- описание типов, переменных, констант и функций.


\chapter{Описания}
Область видимости объекта \texttt{x} (здесь под объектом понимается тип, переменная, константа, или функция) текстуально распространяется от точки его описания до
конца блока (модуля, тела составного оператора, тела функции), которому принадлежит описание и по отношению к которому объект, таким образом, считается локальным. Из
этой области исключаются области видимости объектов с таким же именем, описанных в блоках, вложенных в данный. Правила видимости таковы.
\begin{enumerate}
	\item Идентификатор может обозначать только один объект в данной области видимости (т.е. никакой идентификатор не может быть объявлен в блоке дважды).
	\item На объект можно сослаться только в его области видимости.
	\item Описание типа \texttt{T}, содержащее ссылки на другой тип \texttt{T}$_1$, может стоять в точках, где \texttt{T}$_1$ еще не известен. Описание типа \texttt{T}$_1$
	должно следовать далее в том же блоке, в котором локализован \texttt{T}.
	\item Заголовок функции может быть приведён до того, как будет дано полное определение.
\end{enumerate}

\section{Описание типов}
Описание типов выглядит так:
\begin{center}
	\noindent\textbf{тип} \snotion{имя_типа}\texttt{=}\snotion{определение_типа}\rbo;\snotion{имя_типа}\texttt{=}\snotion{определение_типа}\rbc\kleene
\end{center}

Здесь 
\begin{enumerate}
	\item \snotion{имя_типа} --- идентификатор, являющийся именем определяемого типа;
	\item \snotion{определение_типа} --- либо простейшее определение типа, либо определение алгебраического типа данных.
\end{enumerate}

Алгебраические типы данных будут подробно рассмотрены в разделе, посвящённом таким типам. Здесь же поясним понятие простейшего определения типа.

Простейшие определения типов есть двух категорий:
\begin{enumerate}
	\item стандартные типы;
	\item простейшие определения типов, задаваемые пользователем.
\end{enumerate}

Стандартные типы можно разделить на четыре вида:
\begin{enumerate}
	\item логические типы;
	\item символьный тип;
	\item строковый тип;
	\item числовые типы;
	\item пустой тип.
\end{enumerate}

В свой черёд, числовые типы могут быть следующих подвидов:
\begin{enumerate}
	\item целочисленные типы;
	\item вещественные типы;
	\item комплексные типы.
\end{enumerate}

К простейшим определениям типов, задаваемым пользователем, относятся:
\begin{enumerate}
	\item имя типа;
	\item определение типа--указателя;
	\item определение типа указателя на функцию;
	\item определение типа--массива.
	\item определение типа--множества.
\end{enumerate}

Приведём пример определения типов:

\noindent\textbf{тип}\phantom{m}\texttt{A = }\textbf{мал мал цел}\texttt{;}\\
\phantom{типm|}\texttt{B = }\textbf{мал цел}\texttt{;}\\
\phantom{типm|}\texttt{C = }\textbf{цел}\texttt{;}\\
\phantom{типm|}\texttt{D = }\textbf{бол цел}

Здесь типы \texttt{A} и \textbf{мал мал цел} --- взаимозаменяемы.

Для каждого типа данных можно узнать размер переменной этого типа, для чего перед именем типа или переменной этого типа нужно поставить знак операции \texttt{\#\#}.

Для динамических массивов операция \texttt{\#\#} даёт размер не самого этого значения, а размер служебной информации. Чтобы узнать размер самог\'{о}
значения динамического массива, нужно перед именем переменной поставить знак операции \texttt{\#\#\#}.

\subsection{Логические типы}

Переменная логического типа может принимать только два значения: \textbf{истина} или \textbf{ложь}. Логический тип выглядит так:
\begin{center}
	\rbo\textbf{бол}\sor\textbf{мал}\rbc\kleene \textbf{логик}
\end{center}

Размер переменной типа \textbf{логик} зависит от реализации, но не может превышать размера машинного слова. Также имеются логические типы конкретных размеров, а именно, типы \textbf{логик8}, \textbf{логик16},
\textbf{логик32}, \textbf{логик64}, переменные которых имеют размер в 1, 2, 4 и 8 байт соответственно.

Над логическими значениями определены следующие операции:
\begin{longtable}{ll}
	\texttt{||}             & логическое\ \glqq или\grqq\ (сокращённое вычисление)      \\
	\texttt{||.}            & логическое\ \glqq или\grqq\ (полное вычисление)           \\
	\texttt{!||}            & логическое\ \glqq не--или\grqq\ (сокращённое вычисление)  \\
	\texttt{!||.}           & логическое\ \glqq не--или\grqq\ (полное вычисление)       \\
	\texttt{\&\&}           & логическое\ \glqq и\grqq\ (сокращённое вычисление)        \\
	\texttt{\&\&.}          & логическое\ \glqq и\grqq\ (полное вычисление)             \\
	\texttt{!\&\&}          & логическое\ \glqq не--и\grqq\ (сокращённое вычисление)    \\
	\texttt{!\&\&.}         & логическое\ \glqq не--и\grqq\ (полное вычисление)         \\
	\texttt{\^{ }\^{ }}     & логическое\ \glqq исключающее или\grqq\                   \\
	\texttt{!}              & логическое\ \glqq не\grqq\                                \\
	\texttt{==}             & равно                                                     \\
	\texttt{!=}             & не равно                                                  \\
\end{longtable}


Все логические типы попарно совместимы между собой. Термин\ \glqq полное вычисление\grqq\ означает, что вычисляются все аргументы операции; а термин\ \glqq сокращённое
вычисление\grqq\ --- что вычисляется лишь часть аргументов.

Приведём таблицы истинности логических операций.
\begin{center}
	\vspace{5mm}
	\begin{longtable}{|l|l|l|l|l|}  \hline
		\texttt{x}          & \texttt{y}        & \texttt{x||y}     & \texttt{x\&\&y}   & \texttt{x\^{ }\^{ }y} \\  \hline
		\textbf{ложь}       & \textbf{ложь}     & \textbf{ложь}     & \textbf{ложь}     & \textbf{ложь}         \\  \hline
		\textbf{ложь}       & \textbf{истина}   & \textbf{истина}   & \textbf{ложь}     & \textbf{истина}       \\  \hline
		\textbf{истина}     & \textbf{ложь}     & \textbf{истина}   & \textbf{ложь}     & \textbf{истина}       \\  \hline
		\textbf{истина}     & \textbf{истина}   & \textbf{истина}   & \textbf{истина}   & \textbf{ложь}         \\  \hline
	\end{longtable}
	
	\begin{longtable}{|l|l|l|l|}  \hline
		\texttt{x}          & \texttt{y}        & \texttt{(x!||y)$\equiv$x||(!y)}   & \texttt{(x!\&\&y)$\equiv$x\&\&(!y)}   \\  \hline
		\textbf{ложь}       & \textbf{ложь}     & \textbf{истина}                   & \textbf{ложь}                         \\  \hline
		\textbf{ложь}       & \textbf{истина}   & \textbf{ложь}                     & \textbf{ложь}                         \\  \hline
		\textbf{истина}     & \textbf{ложь}     & \textbf{истина}                   & \textbf{истина}                       \\  \hline
		\textbf{истина}     & \textbf{истина}   & \textbf{ложь}                     & \textbf{ложь}                         \\  \hline
	\end{longtable}
	
	
	\begin{longtable}{|l|l|}  \hline
		\texttt{x}         & \texttt{!x}       \\  \hline
		\textbf{ложь}       & \textbf{истина}   \\  \hline
		\textbf{истина}     & \textbf{ложь}     \\  \hline
	\end{longtable}
\end{center}


\subsection{Символьный тип}
Переменная символьного типа может хранить любой символ, доступный в конкретной реализации. Символьный тип выглядит так:
\begin{center}
	\noindent\textbf{симв}
\end{center}

Для символьных данных определены лишь операции отношения и операция присваивания. Ниже приведён список операций отношения:

\begin{tabular}{ll}
	\texttt{<}         & меньше                                        \\
	\texttt{>}         & больше                                        \\
	\texttt{<=}        & меньше или равно                              \\
	\texttt{>=}        & больше или равно                              \\
	\texttt{==}        & равно                                         \\
	\texttt{!=}        & не равно                                      \\
\end{tabular}   
   
\subsection{Строковый тип}
Переменная строкового типа хранит строковые значения. Строковый тип выглядит так:
\begin{center}
	\noindent\textbf{строка}
\end{center}

Для строковых данных определены операции отношения, операция присваивания, и операция обращения к символу строки по его индексу. Также определена операция конкатенации (склейки) строк, обозначаемая знаком \glqq\texttt{+}\grqq.

\subsection{Числовые типы}
\subsubsection{Целочисленные типы}          
Переменные целочисленных типов хранят целые числа. Целочисленный тип выглядит так:

\noindent\rbo\textbf{бол}\kleene{}\sor\textbf{ мал}\kleene\!\!\rbc \textbf{ бз}\optional \textbf{ цел}\sor\textbf{бз8}\sor\textbf{бз16}\sor\textbf{бз32}\sor\textbf{бз64}\sor\textbf{бз128}\sor\textbf{цел8}\sor\textbf{цел16}\sor\phantom{|}\textbf{цел32}\sor\textbf{цел64}\sor\textbf{цел128}

Допустимые операции:
\begin{longtable}{ll}
 	\texttt{+} (бинарный)   & целочисленное сложение                            \\
 	\texttt{+} (унарный)    & подтверждение знака                               \\
 	\texttt{-} (бинарный)   & целочисленное вычитание                           \\
 	\texttt{-} (унарный)    & изменение знака                                   \\
 	\texttt{+{}+}           & следующее значение                                \\
 	\texttt{-{}-}           & предыдущее значение                               \\
 	\texttt{*}              & целочисленное умножение                           \\
 	\texttt{/}              & целочисленное деление                             \\
 	\texttt{\%}             & целочисленный остаток от деления                  \\
 	\texttt{**}             & целочисленное возведение в степень                \\
 	\texttt{|}              & поразрядное\ \glqq или\grqq\                      \\
 	\texttt{\~{ }|}         & поразрядное\ \glqq не--или\grqq\                  \\
 	\texttt{\&}             & поразрядное\ \glqq и\grqq\                        \\
 	\texttt{\~{ }\&}        & поразрядное\ \glqq не--и\grqq\                    \\
 	\texttt{\~{ }}          & поразрядное\ \glqq не\grqq\                       \\
 	\texttt{\^{ }}          & поразрядное\ \glqq исключающее или\grqq\          \\
 	\texttt{<{}<}           & сдвиг влево                                       \\
 	\texttt{>{}>}           & сдвиг вправо                                      \\
 	\texttt{<}              & меньше                                            \\
 	\texttt{>}              & больше                                            \\
 	\texttt{<=}             & меньше или равно                                  \\
 	\texttt{>=}             & больше или равно                                  \\
 	\texttt{==}             & равно                                             \\
 	\texttt{!=}             & не равно                                          \\
\end{longtable}
       
\subsubsection{Вещественные типы}          
Переменные вещественных типов предназначены для хранения вещественных чисел. Вещественный тип выглядит так:
\begin{center}
	\noindent\rbo\textbf{бол}\kleene\sor\textbf{мал}\kleene\rbc\textbf{вещ}\sor\textbf{вещ32}\sor\textbf{вещ64}\sor\textbf{вещ80}\sor\textbf{вещ128}
\end{center}

Допустимые операции:
\begin{longtable}{ll}
	\texttt{+.}             & сложение                                          \\
	\texttt{+} (унарный)    & подтверждение знака                               \\
	\texttt{-.}             & вычитание                                         \\
	\texttt{-} (унарный)    & изменение знака                                   \\
	\texttt{*.}             & умножение                                         \\
	\texttt{/.}             & деление                                           \\
	\texttt{\%.}            & вещественный остаток от деления                   \\
	\texttt{**.}            & вещественное возведение в степень                 \\
	\texttt{<}              & меньше                                            \\
	\texttt{>}              & больше                                            \\
	\texttt{<=}             & меньше или равно                                  \\
	\texttt{>=}             & больше или равно                                  \\
	\texttt{==}             & равно                                             \\
	\texttt{!=}             & не равно                                          \\
\end{longtable}        

\subsubsection{Комплексные типы}          
Переменные комплексных типов предназначены для хранения комплексных типов. Комплексный тип выглядит так:
\begin{center}
	\noindent\rbo\textbf{бол}\kleene\sor\textbf{мал}\kleene\rbc\textbf{компл}\sor\textbf{компл32}\sor\textbf{компл64}\sor\textbf{компл80}\sor\textbf{компл128}
\end{center}

Допустимые операции:
\begin{longtable}{ll}
	\texttt{+.}             & сложение                                          \\
	\texttt{+} (унарный)    & подтверждение знака                               \\
	\texttt{-.}             & вычитание                                         \\
	\texttt{-} (унарный)    & изменение знака                                   \\
	\texttt{*.}             & умножение                                         \\
	\texttt{/.}             & деление                                           \\
	\texttt{==}             & равно                                             \\
	\texttt{!=}             & не равно                                          \\
\end{longtable}

\subsection{Пустой тип}
Пустой тип --- это тип \textbf{ничего}. Тип \textbf{ничего} может быть либо базовым типом указателя, либо типом значения функции. Ни в каких других целях тип \textbf{ничего} применяться не может. При этом \texttt{\#\#}\textbf{ничего}$=0$, т.е. размер типа \textbf{ничего} равен нулю.

\subsection{Кортежи}
Кортеж --- это упорядоченный набор конечного числа элементов, вообще говоря, разных типов. Тип--кортеж выглядит так:
\begin{center}
	\noindent\texttt{(:}\rbo\snotion{тип_элемента}\rbo,\snotion{тип_элемента}\rbc\kleene\rbc\optional\texttt{:)}
\end{center}        

Здесь \snotion{тип_элемента}  --- тип соответствующего элемента кортежа. Этот тип может быть либо именем типа, либо указателем, либо типом указателя на функцию, либо встроенным типом, либо кортежем.

Если для каждого элемента кортежа определена одна и та же операция отношения, то эта операция определена и для всего кортежа.

Кроме того, если $x$ --- значение--кортеж, то можно получить значения отдельных элементов этого кортежа. А именно, для получения значения элемента с номером $i$ (элементы кортежа нумеруются слева направо, и нумерация начинается с нуля), нужно написать $x\texttt{\#}i$.


\subsection{Указатели}
Указатели содержат адреса ячеек памяти. Тип--указатель определяется так:
\begin{center}
	\texttt{@}\snotion{базовый_тип_указателя}
\end{center}

Указателю можно присвоить константу \textbf{ничего}. В этом случае указатель перестаёт указывать на какую бы то ни было ячейку памяти. Указатель можно разыменовывать, то есть
получать значение переменной, на которую он указывает. Для разыменования указателя нужно после имени указателя поставить знак \texttt{@}. Разыменовывать можно все указатели,
кроме указателей типа \texttt{@}\textbf{ничего}. Тип переменной, на которую указывает указатель, называется базовым типом указателя.

Указатели можно сравнивать на равенство и неравенство. 

Указателю типа \texttt{@}\textbf{ничего} можно присваивать значение указателя любого типа.

\begin{Example}\\
	\rm
	\textbf{перем} \texttt{x : }\textbf{цел};\\
	\hspace*{12mm}\texttt{y : @}\textbf{цел}\\
	\hspace*{12mm}\dots\\
	\hspace*{12mm}x := y@ + 1;\\
	\hspace*{12mm}\dots
\end{Example}

Если нужно получить адрес какой--либо переменной, то перед именем этой переменной нужно записать знак \texttt{@}. Результатом данной операции является указатель, базовый тип которого --- тип переменной. При этом для динамических массив таким образом будет получен лишь адрес области служебных данных. Чтобы получить указатель на начало той области, в которой хранятся данные динамического массива, нужно перед именем переменной, тип которой --- динамический массив, поставить знак \texttt{@@}.

\subsection{Ссылки}
Тип--ссылка выглядит так:        
\begin{center}
	\rbo\textbf{ссылка}\sor\textbf{конст ссылка}\rbc\snotion{базовый_тип_ссылки}
\end{center}      

\subsection{Типы указателей на функции}
Переменные таких типов предназначены для хранения указателей на функции. Тип указателя на функцию выглядит так:
\begin{center}
	\noindent\textbf{чистая}\optional \textbf{фун} \snotion{сигнатура}
\end{center}

Здесь \snotion{сигнатура}определяется следующим образом:

\snotion{сигнатура}\is(\rbo\snotion{группа_параметров}\rbo;\snotion{группа_параметров}\rbc\kleene\rbc\optional):\snotion{тип_значения}

\snotion{группа_параметров}\is\snotion{имя_параметра}\rbo,\snotion{имя_параметра}\rbc\kleene

\snotion{имя_параметра}\is\snotion{идентификатор}

Ключевое слово \textbf{чистая} означает, что у функции нет побочных эффектов. 

\subsection{Массивы}
Тип--массив имеет следующий вид:
\begin{center}
	\textbf{массив}\texttt{[}\snotion{выражение}\optional\rbo,\snotion{выражение}\optional\rbc\kleene\texttt{]} \snotion{тип_элемента_массива}
\end{center}

Каждое из выражений указывает, сколько значений может принимать соответствующий индекс массива. Если какое--либо из выражений опущено, то по этому измерению массив считается динамическим. Каждое выражение должно быть таким, чтобы его можно было вычислить на этапе компиляции. Наименьшее значение каждого индекса равно нулю, а массивы хранятся по строкам.

При этом записи
\begin{center}
	\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$] \textbf{массив}[\texttt{N}$_{m}$,\dots,\texttt{N}$_{m+p-1}$] \texttt{T}
\end{center}
и
\begin{center}
	\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$,\texttt{N}$_{m}$,\dots,\texttt{N}$_{m+p-1}$] \texttt{T}
\end{center}
считаются эквивалентными.

Далее, если тип \texttt{T} определён как
\begin{center}
	\textbf{массив}[\texttt{N}$_{m}$,\dots,\texttt{N}$_{m+p-1}$] \texttt{T}$'$
\end{center}
то запись
\begin{center}
	\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$] \texttt{T}
\end{center}
считается эквивалентной записи
\begin{center}
	\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$,\texttt{N}$_{m}$,\dots,\texttt{N}$_{m+p-1}$] \texttt{T}$'$
\end{center}

Кроме того, любой тип вида
\begin{center}
	\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$] \texttt{T}
\end{center}
где тип \texttt{T} эквивалентен типу \textbf{ничего}, сам эквивалентен типу \textbf{ничего}.

Все эти преобразования производятся на этапе компиляции.

\begin{Example} \textit{Пусть сделаны определения}\\
	\rm
	\textbf{конст} \texttt{N} : \textbf{цел} = 128\\
	\textbf{тип}\hspace*{5mm}\texttt{float} = \textbf{мал вещ};\\
	\hspace*{12mm}\texttt{T} = \textbf{массив}\texttt{[N] float}
	
	\textit{Тогда следующие записи эквивалентны:}
	\begin{enumerate}
		\item
		\textbf{массив}\texttt{[N, N]float}
		\item
		\textbf{массив}\texttt{[N]} \textbf{массив}\texttt{[N] float}
		\item
		\textbf{массив}\texttt{[N] T}
	\end{enumerate}
\end{Example}

Для обращения к элементу массива надо после имени массива в квадратных скобках перечислить индексы нужного элемента.

\begin{Example} \textit{Пусть сделаны определения}\\
	\rm
	\textbf{конст} \texttt{N} : \textbf{цел} = 128;\\
	\hspace*{10mm} \texttt{M} : \textbf{цел} = 256\\
	\\
	\textbf{тип}\hspace*{5mm}\texttt{float} = \textbf{мал вещ};\\
	\hspace*{12mm}\texttt{T1} = \textbf{массив}\texttt{[M] float};\\
	\hspace*{12mm}\texttt{T2} = \textbf{массив}\texttt{[N] T1}\\
	\\
	\textbf{перем} \texttt{A} : \texttt{T1};\\
	\hspace*{11mm} \texttt{B} : \texttt{T2}
	\\
	\textit{Тогда к элементу массива \texttt{A} с индексом 200 нужно обращаться как \texttt{A[200]}, а к имеющему индекс 107 элементу массива \texttt{B} --- \texttt{B[107]}.
		Поскольку, в силу сделанных определений, элемент \texttt{B[107]} сам является массивом, то для обращения к имеющему индекс 91 элементу массива \texttt{B[107]} нужно писать
		\texttt{B[107][91]}. Последняя запись эквивалентна записи \texttt{B[107, 91]}. Аналогичные правила действуют и для массивов большей размерности.}
\end{Example}
       
Тип элемента массива называется базовым типом массива.

Для массивов определена инфиксная бинарная операция \texttt{\#}, первым (левым) операндом которой служит имя массива, а вторым (правым) --- номер индекса массива, считая слева.
Самый левый индекс имеет номер ноль. В результате вычисления данной операции будет получено количество возможных значений указанного вторым операндом индекса. Так происходит,
если второй аргумент неотрицателен и меньше количества индексов (с учётом преобразований этапа компиляции). Если же второй аргумент операции \texttt{\#} либо отрицателен, либо
не меньше количества индексов массива, то результат будет равен нулю.

\begin{Example} \textit{Пусть сделаны определения}\\
	\rm
	\textbf{перем} \texttt{A} : \textbf{массив}\texttt{[16]}\textbf{вещ};\\
	\hspace*{11mm} \texttt{B} : \textbf{массив}\texttt{[9, 11]}\textbf{вещ};\\
	\hspace*{11mm} \texttt{C} : \textbf{массив}\texttt{[17, 8, 19]}\textbf{вещ}\\
	\\
	\textit{Тогда $\texttt{A\#}0=16$, $\texttt{A\#}(-3)=0$, $\texttt{B\#}0=9$, $\texttt{B\#}(-5)=0$, $\texttt{B\#}1=11$, $\texttt{B\#}2=0$, $\texttt{B\#}1000=0$,
		$\texttt{A\#}1=0$, $\texttt{B[3]\#}0=11$, $\texttt{C\#}0=17$, $\texttt{C\#}1=8$, $\texttt{C\#}2=19$, $\texttt{C[5]\#}0=8$, $\texttt{C[5]\#}1=19$, $\texttt{C[5,4]\#}0=19$.}
\end{Example}


\subsection{Перечислимые типы}
Перечислимым называется тип, в определении которого указаны все его возможные значения, являющиеся идентификаторами. Среди этих идентификаторов не должно быть повторяющихся. Определение перечислимого типа выглядит так:
\begin{center}
	\textbf{имя_типа} \texttt{=} \textbf{перечисление} \snotion{имя_перечисления}\{\snotion{имя_значения}\rbo,\snotion{имя_значения}\rbc\kleene\}
\end{center}

Здесь \snotion{имя_значения} --- идентификатор, являющийся именем значения перечислимого типа.

Ниже приведены примеры определения перечислимых типов.

\noindent\textbf{тип} \texttt{светофор = }\textbf{перечисление} \texttt{сф}\texttt{\{красный, жёлтый, зелёный\}};\\
\hspace*{7.5mm}\texttt{день_недели = }\textbf{перечисление} \texttt{дн}\texttt{\{понедельник, вторник, среда, четверг,}\\
\hspace*{65mm}\texttt{пятница, суббота, воскресенье\}};\\
\hspace*{7.5mm}\texttt{месяц_года = }\textbf{перечисление} \texttt{мг}\texttt{\{январь, февраль, март, апрель, май, июнь, июль,}\\
\hspace*{63mm}\texttt{август, сентябрь, октябрь, ноябрь, декабрь\}} 

Для значений перечислимого типа допустимы следующие операции:
\begin{longtable}{ll}
	\texttt{+{}+}           & следующее значение                                \\
	\texttt{-{}-}           & предыдущее значение                               \\
	\texttt{+{}+<}          & следующее значение с заворачиванием               \\
	\texttt{-{}-<}          & предыдущее значение с заворачиванием              \\
	\texttt{<}              & меньше                                            \\
	\texttt{>}              & больше                                            \\
	\texttt{<=}             & меньше или равно                                  \\
	\texttt{>=}             & больше или равно                                  \\
	\texttt{=}              & равно                                             \\
	\texttt{!=}             & не равно                                          \\
\end{longtable}

Поясним смысл этих операций.

Пусть сделано определение вида
\begin{center}
	\noindent\textbf{тип} \texttt{T = }\textbf{перечисление}\texttt{V}\texttt{\{z$_0$, z$_1$,\dots, z$_{m-1}$\}}
\end{center}
\noindent где \texttt{z}$_i$, $i=\overline{0,m-1}$, --- какие--то попарно различные идентификаторы. Пусть, кроме того, \texttt{x} и \texttt{y} --- значения типа \texttt{T}.
Тогда
\begin{gather*}
\texttt{+{}+x}=
\begin{cases}
\text{\texttt{z}$_{i+1}$, если \texttt{x}$=$\texttt{z}$_i$, $i=\overline{0,m-2}$;}\cr
\text{не определено},\text{ если \texttt{x}$=$\texttt{z}$_{m-1}$;}
\end{cases}
\,\,\,
\texttt{+{}+<x}=
\begin{cases}
\text{\texttt{z}$_{i+1}$, если \texttt{x}$=$\texttt{z}$_i$, $i=\overline{0,m-2}$;}\cr
\text{\texttt{z}$_{0}$, если \texttt{x}$=$\texttt{z}$_{m-1}$;}
\end{cases}
\\
\texttt{-{}-x}=
\begin{cases}
\text{\texttt{z}$_{i-1}$, если \texttt{x}$=$\texttt{z}$_i$, $i=\overline{1,m-1}$;}\cr
\text{не определено},\text{ если \texttt{x}$=$\texttt{z}$_{0}$;}
\end{cases}
\,\,\,
\texttt{-{}-<x}=
\begin{cases}
\text{\texttt{z}$_{i-1}$, если \texttt{x}$=$\texttt{z}$_i$, $i=\overline{1,m-1}$;}\cr
\text{\texttt{z}$_{m-1}$, если \texttt{x}$=$\texttt{z}$_{0}$;}
\end{cases}
\\
\texttt{(x < y)}\stackrel{def}{=}(\texttt{код(x)}<\texttt{код(y)}),\,\,\,\texttt{(x <= y)}\stackrel{def}{=}(\texttt{код(x)}\leqslant\texttt{код(y)}),\,\,\,
\texttt{(x > y)}\stackrel{def}{=}(\texttt{код(x)}>\texttt{код(y)}),\\
\texttt{(x >= y)}\stackrel{def}{=}(\texttt{код(x)}\geqslant\texttt{код(y)}),\,\,\,\texttt{(x = y)}\stackrel{def}{=}(\texttt{код(x)}=\texttt{код(y)}),\,\,\,
\texttt{(x != y)}\stackrel{def}{=}(\texttt{код(x)}\neq\texttt{код(y)}).
\end{gather*}

При этом по определению $\texttt{код(x)}=i$, если $\texttt{x}=\texttt{z}_i$ ($i=\overline{0,m-1}$).


\subsection{Множества}
Множеством назовём совокупность объектов, которое может состоять из произвольного числа элементов одного типа. 
Тип-множество имеет следующий вид:

\begin{center}
%\noindent\textcolor{Green}{\syntax{\textcolor{Black}{\textbf{множество}}\textcolor{Black}{(}\synt{элемент множества}\{\textcolor{Black}{, }\synt{элемент множества}\}\textcolor{Black}{)}
%[\synt{простейшее_определение_типа}] }}

\noindent\textcolor{Green}{\syntax{\textcolor{Black}{\textbf{множество}}\synt{ имя_типа} }}
\end{center} 

Здесь \snotion{имя_типа} -- идентификатор, являющийся именем перечислимого типа.	

Каждый элемент множества должен быть таким, чтобы его можно было вычислить на этапе компиляции. В множестве не должно быть повторяющихся элементов. 

%Если не указано простейшее определение типа, то элементами множества могут быть любые идентификаторы.
	
Число элементов множества не может превышать число значений, входящих в простейшее определение типа.

\paragraph{Присваивание значений.}
Объектами множественного типа являются конкретные множества. Обращаться к ним можно с помощью переменных, вводимых обычным путём.
\begin{Example}\\
\rm
\hspace*{4mm} \textbf{тип} месяц = \textbf{перечисление} мес(янв, февр, март, апр, май, июнь, июль, авг, сент, окт, нояб, дек);\\
\hspace*{4mm} A = \textbf{множество} месяц;\\
\hspace*{4mm} \textbf{перем} m : A;\\
\rm
\\
\hspace*{4mm} \textbf{тип} N = \textbf{множество} цел;\\
\hspace*{4mm} \textbf{перем} i : N;\\
\hspace*{4mm} i := (1,2,5,7);\\
\end{Example}

В данном случае значение переменной m может быть произвольная совокупность названий месяца; значение переменной i -- определённый набор цифр из множества целых чисел.

Множество задаётся в виде списка элементов, заключённого в круглые скобки. В скобках может не быть элементов, может стоять только один элемент или может присутствовать несколько
элементов, разделённых запятыми. В качестве элемента может выступать константа, переменная или выражение, значения которых принадлежат определению типа множества, а также пара элементов, разделённых двумя точками, т.е. интервал значений.

Следовательно, можно использовать инструкции присваивания следующих видов:
\begin{flushleft}
\hspace*{5mm} m := (); (* пустое множество *) \\
\hspace*{5mm} m := (янв); (* множество включает только один элемент *) \\
\hspace*{5mm} m := (янв .. март, авг, нояб .. дек); (* в множество входят элементы янв, февр, март, авг, \hspace*{5mm} нояб, дек *) \\
\end{flushleft}

\paragraph{Операции над множествами.}
Средства, предназначенные для создания множеств и присваивания им значений, не позволяют в полной мере использовать возможности данных множественного типа. В связи с этим введены такие операции:
\begin{enumerate}
\item
\textbf{Объединение}\\
В объединение множеств L + R входят элементы, которые являются членами хотя бы одного из множеств L или R.
\item
\textbf{Пересечение}\\
В пересечение множеств L * R входят элементы, принадлежащие и множеству L, и множеству R.
\item
\textbf{Разность}\\
В разность множеств L -- R входят элементы, которые являются членами множества L и не являются членами множества R.
\end{enumerate}

\begin{Example}
\textit{Пусть сделаны определения}\\
\rm 	
\hspace*{5mm} \textbf{тип} \texttt{C} = \textbf{множество}(анна, елена, соня, геля, лиза, мария, света, саша);\\
\hspace*{5mm} \textbf{перем} \texttt{A, B} : C;\\

\textit{и две конструкции присваивания:}\\
\hspace*{5mm} A := (анна, соня, мария .. саша); \\
\hspace*{5mm} B := (анна, лиза, мария, света); \\
\end{Example}
В результате выполнения двум множествам A и B (в множество A включены имена спортивных девушек, а в множество B -- имена девушек, которые занимаются рисованием) присваиваются конкретные значения.

Тогда результатом A + B является множество имён тех девушек, которые или занимаются спортом, или хороши в искусстве, или и спортивны, и рисуют. В это множество войдут анна, соня, лиза, мария, света, саша.

Результатом A * B является множество, в которое входят имена спортивных и творческих девушек, т.е. анна, мария, света.

Наконец, результатом A -- B является множество имён девушек, которые спортивны, но не занимаются рисованием. Это соня и саша.\\

Оператор \textbf{в} позволяет определить, принадлежит элемент множеству или нет. Первым операндом, расположенным слева от слова \textbf{в}, является значением простейшего определения типа, а вторым операндом, стоящим справа, имя множества. Результатом являются значения типа boolean: true -- если значение является элементом множества; false -- если не является.
Следовательно,
\begin{flushleft}
\hspace*{5mm} лиза \textbf{в} B \\
\hspace*{5mm} даёт в результате true, а \\
\hspace*{5mm} геля \textbf{в} (A + B) \\
\hspace*{5mm} даёт false \\
\end{flushleft}

При работе с множествами можно использовать операторы сравнения. Операторы = и < > позволяют проверить, равны два множества или нет. Операторы <= и >= называются операторами включения. С их помощью легко определить, является ли одно множество подмножеством другого. 
Например, отношение \\
\hspace*{5mm} (анна, света) <= (A + B) \\
истинно, поскольку все элементы, стоящие слева, содержатся в множестве, расположенном справа.

Расположим операторы, предназначенные для работы с множествами, в порядке убывания приоритета:

\begin{enumerate}
\item
\textbf{*}\\
\item
\textbf{+, --}\\
\item
\textbf{в, =, < >, <=, >=}\\
\end{enumerate}
В группы объединены операторы равного приоритета. Последовательность выполнения операторов одного приоритета определяется порядком их появления в выражении. Для изменения порядка выполнения операторов используются круглые скобки.


\subsection{Структуры}
Структура --- это упорядоченный набор компонент, вообще говоря, различных типов. Каждая такая компонента называется полем структуры. Синтаксис описания типа--структуры:

\snotion{тип_структура} \texttt{=} \textbf{структ} \snotion{имя_структуры} \texttt{\{}\snotion{группа_полей}\rbo;\snotion{группа_полей}\rbc\kleene\texttt{\}}

\snotion{группа_полей}\is\snotion{имя_поля}\rbo,\snotion{имя_поля}\rbc\kleene:\snotion{определение_типа}

\snotion{имя_поля}\is\snotion{идентификатор}

\begin{Example} \textit{Пусть сделаны определения}\\
	\\
	\rm
	\textbf{тип} \texttt{дата = } \textbf{структ} \texttt{дата\{}\\
	\hspace*{27mm}\texttt{день: }\textbf{цел8}\texttt{;}\\
	\hspace*{27mm}\texttt{месяц: }\textbf{цел8}\texttt{;}\\
	\hspace*{27mm}\texttt{месяц: }\textbf{цел16}\\
	\hspace*{8mm}\texttt{\}}
	\\
	\textbf{перем} \texttt{x} : \texttt{дата}\\
	\\
	\textit{Тогда для обращения к полю \texttt{день} переменной \texttt{x} нужно записать \texttt{x.день}.}
\end{Example}

\subsection{Алгебраические типы данных}
Более общим способом определения типа, по сравнению с определением типа--структуры и типа--перечисления, является определение алгебраического типа данных. Алгебраический тип данных определяется так:

\snotion{опр_алгебр_типа}\is\snotion{имя_типа} \texttt{=} \snotion{компонента} \rbo\texttt{.|.}\snotion{компонента}\rbc\kleene

\snotion{компонента}\snotion{опр_структуры}\sor\snotion{опр_перечисления}

\snotion{опр_структуры}\is\textbf{структ} \snotion{имя_структуры} \texttt{\{}\snotion{тело_структуры}\optional\texttt{\}}

\snotion{тело_структуры}\is\snotion{группа_полей}\rbo;\snotion{группа_полей}\rbc\kleene

\snotion{группа_полей}\is\snotion{имя_поля}\rbo,\snotion{имя_поля}\rbc\kleene:\snotion{определение_типа}

\snotion{имя_поля}\is\snotion{идентификатор}

\snotion{имя_структуры}\is\snotion{идентификатор}

\snotion{имя_типа}\is\snotion{идентификатор}

\snotion{опр_перечисления}\is\textbf{перечисление} \snotion{имя_перечисления}\{\snotion{имя_значения}\rbo,\snotion{имя_значения}\rbc\kleene\}

\snotion{имя_значения}\is\snotion{идентификатор}

Здесь разделитель \texttt{.|.} означает \glqq{}или\grqq.


\subsection{Эквивалентность и совместимость типов}
Выше использовалось понятие эквивалентности типов. Определим это понятие. Но сначала дадим определение \textit{правильного типа--массива}.

Тип--массив \texttt{T} назовём \textit{правильным типом--массивом}, если \texttt{T} имеет вид \textbf{массив}\texttt{[N$_0$},\dots,\texttt{N$_{m-1}$]T}$'$, где $\texttt{T}'$
не является массивом, а \texttt{N$_0$},\dots,\texttt{N$_{m-1}$} --- неотрицательные целочисленные константы. Для каждой из этих констант положительное
значение имеет смысл количества значений соответствующего индекса массива; а нулевое означает, что по этому измерению массив является динамическим. Если тип $\texttt{T}'$
--- это тип \textbf{ничего}, то считаем, что тип \texttt{T} эквивалентен типу \textbf{ничего}.

На этапе компиляции каждый тип преобразуется к виду \textcolor{Green}{\syntax{\{\textcolor{Black}{@}\}\textcolor{Black}{\texttt{T}}}}, где \texttt{T} --- что--либо из
следующего списка:
\begin{enumerate}
	\item символьный тип;
	\item логический тип;
	\item целочисленный тип;
	\item вещественный тип;
	\item комплексный тип;
	\item пустой тип;
	\item алгебраический тип;
	\item тип указателя на функцию;
	\item правильный тип--массив.
\end{enumerate}

Такой вид типа назовём \textit{каноническим}. Будем считать, что все компоненты тех компонент алгебраических типов, которые являются структурами, приведены к каноническому виду.

Количество символов @ в каноническом виде типа \texttt{T} будем называть \textit{ссылочным порядком типа \texttt{T}},  и обозначать \texttt{сп(T)}. Эквивалентность типов
\texttt{T$_1$} и \texttt{T$_2$} будем обозначать так: ${\texttt{T}}_1\sim{\texttt{T}}_2$.

Наконец, дадим определение эквивалентности типов.
\begin{Definition}
	\renewcommand{\theenumii}{\asbuk{enumii}}
	\renewcommand{\labelenumii}{\theenumii)}
	\begin{enumerate}
		\item Для любого типа \texttt{T} справедливо соотношение ${\texttt{T}}\sim{\texttt{T}}$.
		\item Если ${\texttt{T}}_1\sim{\texttt{T}}_2$, то ${\texttt{T}}_2\sim{\texttt{T}}_1$.
		\item Если ${\texttt{T}}_1\sim{\texttt{T}}_2$ и ${\texttt{T}}_2\sim{\texttt{T}}_3$, то ${\texttt{T}}_1\sim{\texttt{T}}_3$.
		\item Разные стандартные типы не эквивалентны.
		\item Если сделано определение вида \textbf{тип} \texttt{T$_1$ = T$_2$}, то ${\texttt{T}}_1\sim{\texttt{T}}_2$.
		\item Если $\texttt{сп}({\texttt{T}}_1)\neq\texttt{сп}({\texttt{T}}_2)$, то ${\texttt{T}}_1\not\sim{\texttt{T}}_2$.
		\item Пусть даны два типа, \texttt{T$_1$} и \texttt{T$_2$}, у которых $\texttt{сп}({\texttt{T}}_1)=\texttt{сп}({\texttt{T}}_2)>0$. Пусть, кроме того,
		\textcolor{Green}{\syntax{\{\textcolor{Black}{@}\}\textcolor{Black}{\texttt{T}$'_1$}}} --- канонический вид типа \texttt{T$_1$}, а
		\textcolor{Green}{\syntax{\{\textcolor{Black}{@}\}\textcolor{Black}{\texttt{T}$'_2$}}} --- канонический вид типа \texttt{T$_2$}. Тогда ${\texttt{T}}_1\sim{\texttt{T}}_2$
		в том и только в том случае, когда ${\texttt{T}}'_1\sim{\texttt{T}}'_2$.
		\item Два правильных типа--массива эквивалентны тогда и только тогда, когда
		\begin{enumerate}
			\item у массивов --- одинаковое количество индексов;
			\item количество значений соответствующих индексов совпадает;
			\item базовые типы эквивалентны.
		\end{enumerate}
		\item Два типа указателей на функции эквивалентны только при одновременном выполнении следующих условий:
		\begin{enumerate}
			\item количество формальных параметров совпадает;
			\item соответствующие параметры имеют эквивалентные типы;
			\item типы возвращаемых значений эквивалентны;
			\item либо оба типа чистые (т.е. с атрибутом \textbf{чистая}), либо оба типа --- грязные (т.е. без указанного атрибута).
		\end{enumerate}
		\item Во всех не упомянутых здесь случаях типы неэквивалентны.
	\end{enumerate}
\end{Definition}

При использовании в программе эквивалентные типы взаимозаменяемы.

При вызове функции необходимо, чтобы типы формальных и фактических параметров были определённым образом согласованы. Можно было бы
отождествить такую согласованность с эквивалентностью типов формальных и фактических параметров, но это было бы слишком жёстким требованием. Таким образом, нам необходимо
понятие согласованности типов, отличающееся от понятия эквивалентности типов. Нужную нам согласованность назовём \textit{совместимостью} типов. Тот факт, что тип
\texttt{T$_1$} совместим с типом \texttt{T$_2$}, будем обозначать так: ${\texttt{T}}_1\rhd{\texttt{T}}_2$.

Дадим определение совместимости типов.
\begin{Definition}
	\renewcommand{\theenumii}{\asbuk{enumii}}
	\renewcommand{\labelenumii}{\theenumii)}
	\begin{enumerate}
		\item Если ${\texttt{T}}_1\sim{\texttt{T}}_2$, то ${\texttt{T}}_1\rhd{\texttt{T}}_2$ и ${\texttt{T}}_2\rhd{\texttt{T}}_1$.
		\item Каждый из алгебраических типов совместим только сам с собою.
		\item Каждый из символьных типов совместим только сам с собою.
		\item Все логические типы попарно совместимы между собой.
		\item Если \texttt{T$_1$} и \texttt{T$_2$} --- целочисленные типы и диапазон значений типа \texttt{T$_1$} содержится в диапазоне значений типа \texttt{T$_2$},
		то ${\texttt{T}}_1\rhd{\texttt{T}}_2$.
		\item Если \texttt{T$_1$} и \texttt{T$_2$} --- вещественные типы и точность типа \texttt{T$_1$} не превышает точности типа \texttt{T$_2$}, то
		${\texttt{T}}_1\rhd{\texttt{T}}_2$.
		\item Если \texttt{T$_1$} и \texttt{T$_2$} --- комплексные типы и точность компонент типа \texttt{T$_1$} не превышает точности компонент типа \texttt{T$_2$}, то
		${\texttt{T}}_1\rhd{\texttt{T}}_2$.
		\item Если \texttt{T$_1$} --- целочисленный тип, а \texttt{T$_2$} --- вещественный или комплексный тип, то ${\texttt{T}}_1\rhd{\texttt{T}}_2$.
		\item Если \texttt{T$_1$} --- вещественный тип, а \texttt{T$_2$} --- комплексный тип, причём точность типа \texttt{T$_1$} не превышает точности компонент
		типа \texttt{T$_2$}, то ${\texttt{T}}_1\rhd{\texttt{T}}_2$.
		\item Пусть \texttt{T$_1$} и \texttt{T$_2$} --- типы--массивы. Обозначим через \texttt{B$_1$} и \texttt{B$_2$} базовые типы типов \texttt{T$_1$} и \texttt{T$_2$}
		соответственно; через $d_1$ и $d_2$ --- количество индексов у \texttt{T$_1$} и \texttt{T$_2$} соответственно; наконец, через $N_1^j$, $j=\overline{0,d_1-1}$, обозначим
		количество значений индекса с номером $j$ у массива \texttt{T$_1$}, а через $N_2^j$, $j=\overline{0,d_2-1}$, --- количество значений индекса с номером $j$ у массива
		\texttt{T$_2$}. Тогда ${\texttt{T}}_1\rhd{\texttt{T}}_2$ только при одновременном выполнении следующих условий:
		\begin{enumerate}
			\item $d_1=d_2$;
			\item ${\texttt{B}}_1\rhd{\texttt{B}}_2$;
			\item если $N_2^j=0$, то $N_1^j$ может быть любым; в противном случае должно выполняться равенство $N_1^j=N_2^j$ ($j=\overline{0,d_1-1}$).
		\end{enumerate}
		\item Во всех не упомянутых здесь случаях типы несовместимы.
	\end{enumerate}
\end{Definition}


\section{Описание переменных}  
Синтаксис описания переменных:

\snotion{описание_переменных}\is\textbf{перем} \snotion{группа_переменных}:\snotion{определение_типа}\rbo\texttt{ = }\snotion{выражение}\rbc\optional\\
\phantom{описание_переменных123456789234}\rbo;\snotion{группа_переменных}:\snotion{определение_типа}\rbo\texttt{ = }\snotion{выражение}\rbc\optional\rbc\kleene

\snotion{группа_переменных}\is\snotion{имя_переменной}\rbo,\snotion{имя_переменной}\rbc\kleene

\snotion{имя_переменной}\is\snotion{идентификатор}


\section{Описание констант}
Синтаксис описания констант:

\snotion{описание_констант}\is\snotion{имя_константы} : \snotion{тип_константы} \texttt{=} \snotion{значение_константы}\\
\phantom{описание_констант88883}\rbo;\snotion{имя_константы} : \snotion{тип_константы} \texttt{=} \snotion{значение_константы}\rbc\kleene

\snotion{имя_константы}\is\snotion{идентификатор}

\snotion{значение_константы}\is\snotion{выражение}


\section{Описание функций}
Описание функции имеет следующую структуру:

\snotion{описание_функции}\is\rbo\textbf{глав} \sor \textbf{чистая}\rbc\optional \textbf{фун} \snotion{имя_функции} \snotion{сигнатура}\rbo;\sor\snotion{реализация}\rbc

\snotion{реализация}\is\texttt{\{}\rbo\snotion{описание}\sor\snotion{операторы}\rbc\kleene\texttt{\}}

\snotion{имя_функции}\is\snotion{идентификатор}

Необязательное ключевое слово \textbf{глав} означает, что выполнение модуля начинается с этой функции. Функций с атрибутом \textbf{глав} в модуле может быть не более одной.

Необязательное ключевое слово \textbf{чистая} означает, что функция не имеет побочных эффектов.   


\chapter{Выражения}
Синтаксис выражений выглядит так:

\snotion{выражение}\is\snotion{выражение}$_0$\rbo\snotion{операция_присваивания} \snotion{выражение}\rbc\optional

\snotion{операция_присваивания}\is\texttt{=} \sor \texttt{:=} \sor \texttt{||=} \sor \texttt{!||=} \sor \texttt{||.=} \sor \texttt{!||.=} \sor \texttt{\&\&=} \sor \texttt{\&\&.=} \sor \texttt{!\&\&=} \sor \texttt{!\&\&.=} \sor \texttt{\^{ }\^{ }=} \sor \texttt{|=} \sor \texttt{\&=} \sor \\
\phantom{операция_присваивания88888} \texttt{\~{ }|=} \sor \texttt{\~{ }\&=} \sor \texttt{\^{ }=} \sor \texttt{<{}<=} \sor \texttt{>{}>=} \sor \texttt{+=} \sor \texttt{-=} \sor \texttt{*=} \sor \texttt{/=} \sor \texttt{\%=} \sor \texttt{**=} \sor \texttt{+.=} \sor \texttt{-.=} \sor \texttt{*.=} \sor \texttt{/.=} \sor\\
\phantom{операция_присваивания88888} \texttt{\%.=} \sor \texttt{**.=} 

\snotion{выражение}$_0$\is\snotion{выражение}$_1$\rbo\rbo\texttt{?} \sor \texttt{?.}\rbc\snotion{выражение}$_1$ : \snotion{выражение}$_1$\rbc\optional

\snotion{выражение}$_1$\is\snotion{выражение}$_2$\rbo \rbo \texttt{||} \sor \texttt{||.} \sor \texttt{!||} \sor \texttt{!||.} \sor \texttt{\^{ }\^{ }}\rbc\snotion{выражение}$_2$\rbc\kleene

\snotion{выражение}$_2$\is\snotion{выражение}$_3$\rbo \rbo \texttt{\&\&} \sor \texttt{\&\&.} \sor \texttt{!\&\&} \sor \texttt{!\&\&.}\rbc\snotion{выражение}$_3$\rbc\kleene

\snotion{выражение}$_3$\is\rbo\texttt{!}\rbc\kleene\snotion{выражение}$_4$

\snotion{выражение}$_4$\is\snotion{выражение}$_5$\rbo \rbo \texttt{<} \sor \texttt{>} \sor \texttt{<=} \sor \texttt{>=} \sor \texttt{==} \sor \texttt{!=}\rbc\snotion{выражение}$_5$\rbc\kleene

\snotion{выражение}$_5$\is\snotion{выражение}$_6$\rbo \rbo \texttt{|} \sor\texttt{\~{ }|} \sor \texttt{\^{ }}\rbc\snotion{выражение}$_6$\rbc\kleene

\snotion{выражение}$_6$\is\snotion{выражение}$_7$\rbo \rbo \texttt{\&} \sor \texttt{\~{ }\&} \sor \texttt{<{}<} \sor \texttt{>{}>}\rbc\snotion{выражение}$_7$\rbc\kleene

\snotion{выражение}$_7$\is\rbo\texttt{\~{ }}\rbc\kleene\snotion{выражение}$_8$

\snotion{выражение}$_8$\is\snotion{выражение}$_9$\rbo \rbo \texttt{+} \sor \texttt{+.} \sor \texttt{-} \sor \texttt{-.}\rbc\snotion{выражение}$_9$\rbc\kleene

\snotion{выражение}$_9$\is\snotion{выражение}$_{10}$\rbo\rbo\texttt{*} \sor \texttt{*.} \sor \texttt{/} \sor \texttt{/.} \sor \texttt{\%} \sor \texttt{\%.}\rbc\snotion{выражение}$_{10}$\rbc\kleene

\snotion{выражение}$_{10}$\is\snotion{выражение}$_{11}$\rbo\rbo\texttt{**} \sor \texttt{**.}\rbc\snotion{выражение}$_{10}$\rbc\optional

\snotion{выражение}$_{11}$\is\snotion{выражение}$_{12}$\rbo\texttt{\#}\snotion{выражение}$_{12}$\rbc\optional
        
\snotion{выражение}$_{12}$\is\rbo \texttt{+{}+}\sor \texttt{-{}-} \sor \texttt{+{}+<} \sor \texttt{-{}-<}\rbc\kleene\snotion{выражение}$_{13}$

\snotion{выражение}$_{13}$\is\rbo\texttt{+} \sor \texttt{-}\rbc\snotion{выражение}$_{14}$

\snotion{выражение}$_{14}$\is\rbo\texttt{@} \sor \texttt{@@} \sor \texttt{\#\#} \sor \texttt{\#\#\#}\rbc\optional\snotion{выражение}$_{15}$

\snotion{выражение}$_{15}$\is\snotion{выделение_памяти} \sor \snotion{освобождение_памяти} \sor \snotion{литерал} \sor\\
\phantom{выражение8888888}\snotion{имя} \sor (\snotion{выражение}) \sor \snotion{составное_значение}

\snotion{выделение_памяти}\is\textbf{выдел}\rbo\texttt{[:}\snotion{выражение}\rbo,\snotion{выражение}\rbc\kleene\texttt{:]}\rbc\optional\snotion{имя}

\snotion{освобождение_памяти}\is\textbf{очищ}\rbo\texttt{[:}\texttt{:]}\rbc\optional\snotion{имя}

\snotion{литерал}\is\snotion{символьный} \sor \snotion{строковый}  \sor \snotion{целое} \sor \snotion{вещественное} \sor \snotion{комплексное} \sor \textbf{истина} \sor \textbf{ложь} \sor \textbf{ничего}

\snotion{имя}\is\rbo\snotion{идентификатор}\texttt{::}\rbc\kleene\snotion{идентификатор}\rbo\texttt{.}\snotion{идентификатор} \sor \texttt{@} \sor  \texttt{(}\rbo\snotion{выражение}\rbo,\snotion{выражение}\rbc\kleene\rbc\optional\texttt{)} \sor\\
\phantom{имя88888}\texttt{[}\rbo\snotion{выражение}\rbo,\snotion{выражение}\rbc\kleene\rbc\optional\texttt{]}\rbc\kleene

\snotion{составное_значение}\is\snotion{значение_структуры} \sor \snotion{значение_массива}

\snotion{значение_структуры}\is\snotion{идентификатор}\texttt{\{}\rbo\snotion{имя_поля}\texttt{<-}\snotion{выражение}\rbo,\snotion{имя_поля}\texttt{<-}\snotion{выражение}\rbc\kleene\rbc\optional\texttt{\}}

\snotion{значение_массива}\is\textbf{массив}\texttt{[:}\snotion{выражение}\optional\rbo,\snotion{выражение}\optional\rbc\kleene\texttt{:]}\texttt{\{}\snotion{выражение}\rbo,\snotion{выражение}\rbc\kleene \texttt{\}}

   
\chapter{Операторы}
\section{Операторы присваивания}
Синтаксис оператора присваивания:
\begin{center}
	\snotion{имя} \snotion{операция_присваивания} \snotion{выражение}
\end{center}

Все эти операторы можно разделить на три группы: простой оператор присваивания (\texttt{=}), оператор копирования (\texttt{:=}) и все прочие операторы присваивания.
Отличие оператора копирования от оператора присваивания состоит в поведении для динамических массивов: в этом случае оператор присваивания копирует
ссылки на значения (точнее, служебные сведения, в которые входят эти ссылки), а оператор копирования копирует сами значения. 

\section{Условный оператор}
Синтаксис условного оператора:

\snotion{условный_оператор}\is\textbf{если} \snotion{условие} \textbf{то}\texttt{\{}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\texttt{\}}\\
\phantom{условный_оператор88888}\rbo\textbf{иначеесли} \snotion{условие} \textbf{то}\texttt{\{}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\texttt{\}}\rbc\kleene\\
\phantom{условный_оператор88888}\textbf{иначе}\texttt{\{}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\texttt{\}}


Здесь \snotion{условие} --- это логическое выражение, а \textbf{иначеесли} \snotion{условие} \textbf{то}\texttt{\{}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\texttt{\}} является сокращённой формой для
\textbf{иначе}\texttt{\{}\textbf{если} \snotion{условие} \textbf{то}\texttt{\{}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\texttt{\}}\texttt{\}}.

\section{Оператор выбора}
Синтаксис оператора выбора:

\snotion{оператор_выбора}\is\textbf{выбор} \snotion{выражение} \texttt{\{}\\
\phantom{оператор_выбора8888888}\snotion{список_значений_для_ветви} \texttt{:} \texttt{\{}\snotion{ветвь}\texttt{\}}\\
\phantom{оператор_выбора8888888}\rbo\snotion{список_значений_для_ветви} \texttt{:} \texttt{\{}\snotion{ветвь}\texttt{\}}\rbc\kleene\\
\phantom{оператор_выбора8888888}\rbo\textbf{иначе}\texttt{\{}\snotion{ветвь_иначе}\texttt{\}}\rbc\optional\\
\phantom{оператор_выбора88}\indent\texttt{\}}

\snotion{список_значений_для_ветви}\is\snotion{значение_для_ветви}\rbo,\snotion{значение_для_ветви}\rbc\kleene

\snotion{значение_для_ветви}\is\snotion{выражение}\rbo\texttt{..}\snotion{выражение}\rbc\optional

\snotion{ветвь}\is\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene

\snotion{ветвь_иначе}\is\snotion{ветвь}

Оператор выбора определяет выбор и выполнение операторов на основе значения выражения \textcolor{Green}{\syntax{\synt{S}}}, которое должно быть выражением целочисленного, перечислимого, или символьного типа.

Оператор выполняется так. Сначала вычисляется выражение, идущее сразу после ключевого слова \textbf{выбор}. Затем выполняется та ветвь (т.е. последовательность операторов), соответствующий которой список значений содержит значение выражения \textcolor{Green}{\syntax{\synt{S}}}. При этом можно указывать диапазоны значений, а именно, следующим образом: \texttt{A..B}, где \texttt{A} --- минимальное значение в диапазоне, \texttt{B} --- максимальное значение в диапазоне. Например, \texttt{1..2000}, \texttt{-7..7}. Значения в списках значений должны быть константами, которые можно вычислить на этапе компиляции, и ни одно значение не должно употребляться
более одного раза.  Если нужного значения нет в списке значений ни для какой ветви, то выполняются операторы ветви \snotion{ветвь_иначе}, если ключевое слово \textbf{иначе} присутствует. Если же ключевого слова \textbf{иначе} нет, то выполнение оператора выбора завершается.

\section{Оператор разбора значения алгебраического типа}
Синтаксис оператора разбора:

\snotion{оператор_разбора}\is\textbf{разбор} \snotion{выражение} \texttt{\{}\\
\phantom{оператор_выбора8888888}\snotion{метка_разбора}\texttt{->}\texttt{\{}\snotion{ветвь}\texttt{\}}\\
\phantom{оператор_выбора8888888}\rbo\snotion{метка_разбора}\texttt{->}\texttt{\{}\snotion{ветвь}\texttt{\}}\rbc\kleene\\
\phantom{оператор_выбора8888888}\rbo\textbf{иначе}\texttt{\{}\snotion{ветвь_иначе}\texttt{\}}\rbc\optional\\
\phantom{оператор_выбора88}\indent\texttt{\}}

\snotion{метка_разбора}\is\snotion{имя_компоненты_алгебраического_типа}\texttt{\{..\}}

\snotion{имя_компоненты_алгебраического_типа}\is\rbo\snotion{идентификатор}\texttt{::}\rbc\kleene\snotion{идентификатор}

\section{Операторы цикла}
Операторы цикла организуют выполнение повторяющихся действий. Всего в языке есть четыре типа операторов цикла: оператор цикла с предусловием (оператор \textbf{\glqq пока\grqq}),
оператор цикла с постусловием (оператор \textbf{\glqq повт\dots пока\grqq}), оператор \textbf{\glqq бескон повт\grqq}, оператор \textbf{\glqq для\grqq}. Опишем каждый из этих операторов.

\subsection{Оператор цикла с предусловием}
Оператор цикла с предусловием выглядит так:
\begin{center}
	\rbo\texttt{+|}\snotion{имя_цикла}\texttt{:}\rbc\optional\textbf{пока}\texttt{(}\snotion{условие}\texttt{)}\texttt{\{}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\texttt{\}}
\end{center}
Здесь \snotion{условие} --- это логическое выражение, а  \snotion{имя_цикла} --- идентификатор, являющийся именем цикла. Данный идентификатор можно использовать только в операторе выхода из цикла. Оператор \textbf{\glqq пока\grqq}\ выполняет тело цикла, пока логическое выражение \snotion{условие} остаётся истинным. Истинность этого логического выражения проверяется перед каждым выполнением тела цикла.

\subsection{Оператор цикла с постусловием}
Оператор цикла с постусловием выглядит так:
\begin{center}
	\rbo\texttt{+|}\snotion{имя_цикла}\texttt{:}\rbc\optional\textbf{повт}\texttt{\{}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\texttt{\}}\textbf{пока}\texttt{(}\snotion{условие}\texttt{)}
\end{center}
Здесь \snotion{условие} --- это логическое выражение, а  \textcolor{Green}{\syntax{\synt{имя_цикла}}} --- идентификатор, являющийся именем цикла. Данный идентификатор можно использовать только в операторе выхода из цикла. Оператор цикла \textbf{\glqq повт\dots пока\grqq}\ выполняет тело цикла, пока логическое выражение \snotion{условие} остаётся истинным. Истинность этого логического выражения проверяется после каждого выполнения тела цикла.   

\subsection{Оператор цикла \glqq бескон повт\grqq}
Оператор \textbf{\glqq бескон\dots повт\grqq} выглядит так:
\begin{center}
	\rbo\texttt{+|}\snotion{имя_цикла}\texttt{:}\rbc\optional\textbf{бескон} \textbf{повт}\texttt{\{}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\texttt{\}}
\end{center}
Здесь \textcolor{Green}{\syntax{\synt{имя_цикла}}} --- идентификатор, являющийся именем цикла. Данный идентификатор можно использовать только в операторе выхода из цикла. Оператор \textbf{\glqq бескон повт\grqq} выполняется до тех пор, пока из него не будет совершён явный выход --- либо с помощью оператора выхода из цикла, либо с помощью оператора возврата из подпрограммы.
   
\subsection{Оператор цикла \glqq для\grqq}
Оператор цикла \textbf{\glqq для\grqq}\ выглядит так:
\begin{center}
	\rbo\texttt{+|}\snotion{имя_цикла}\texttt{:}\rbc\optional \textbf{для} \textcolor{Green}{\syntax{\synt{v}}} \texttt{=} \texttt{нач_знач}, \texttt{кон_знач}\rbo\texttt{, шаг}\rbc\optional
	\texttt{\{}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\texttt{\}}
\end{center}

Здесь \textcolor{Green}{\syntax{\synt{v}}} --- идентификатор, являющийся именем переменной цикла; \texttt{нач_знач} --- начальное значение переменной цикла;
\texttt{кон_знач} --- конечное значение переменной цикла; \texttt{шаг} --- шаг цикла. По умолчанию шаг равен единице. Величины \texttt{нач_знач}, \texttt{кон_знач} и
\texttt{шаг} являются выражениями, вычисляемыми до начала цикла. Переменная цикла должна быть символьного, целочисленного или перечислимого типа. Выражения \texttt{нач_знач} и
\texttt{кон_знач} должны иметь тип, совместимый с типом переменной \textcolor{Green}{\syntax{\synt{v}}}, а выражение \texttt{шаг} должно быть целочисленного типа.
Менять в теле цикла значение переменной цикла нельзя.

Смысл оператора цикла \textbf{\glqq для\grqq}:

\noindent\textcolor{Green}{\syntax{%
		\textcolor{Black}{t$_1$} \textcolor{Black}{\texttt{:=}} \textcolor{Black}{\texttt{нач_знач};}\\
		\textcolor{Black}{t$_2$} \textcolor{Black}{\texttt{:=}} \textcolor{Black}{\texttt{кон_знач};}\\
		\textcolor{Black}{t$_3$} \textcolor{Black}{\texttt{:=}} \textcolor{Black}{\texttt{шаг};}\\
		\textcolor{Black}{\textbf{если}}\textcolor{Black}{\texttt{(}}\textcolor{Black}{t$_3$} \textcolor{Black}{\texttt{>}} \textcolor{Black}{0}\textcolor{Black}{\texttt{)}}%
		\textcolor{Black}{\textbf{то}}\\
		\textcolor{Black}{\texttt{\{}}\\
		\phantom{конец}\synt{v} \textcolor{Black}{\texttt{:=}} \textcolor{Black}{t$_1$}\textcolor{Black}{;}\\
		\phantom{конец}\textcolor{Black}{\textbf{пока}}\textcolor{Black}{\texttt{(}}\synt{v} \textcolor{Black}{\texttt{<=}} \textcolor{Black}{t$_2$}\textcolor{Black}{\texttt{)}}\\
		\phantom{конец}\textcolor{Black}{\texttt{\{}}\\
		\phantom{конецмоимс}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\\
		\phantom{конецмоимс}\textcolor{Black}{\texttt{увелич}}\textcolor{Black}{\texttt{(}}\synt{v}\textcolor{Black}{\texttt{,}} \textcolor{Black}{t$_3$}\textcolor{Black}{\texttt{)}}\\
		\phantom{конец}\textcolor{Black}{\texttt{\}}}\\
		\textcolor{Black}{\texttt{\}}}\textcolor{Black}{\textbf{иначеесли}}\textcolor{Black}{\texttt{(}}\textcolor{Black}{t$_3$} \textcolor{Black}{\texttt{<}} \textcolor{Black}{0}\textcolor{Black}{\texttt{)}}%
		\textcolor{Black}{\textbf{то}}\\
		\textcolor{Black}{\texttt{\{}}\\
		\phantom{конец}\synt{v} \textcolor{Black}{\texttt{:=}} \textcolor{Black}{t$_1$}\textcolor{Black}{;}\\
		\phantom{конец}\textcolor{Black}{\textbf{пока}}\textcolor{Black}{\texttt{(}}\synt{v} \textcolor{Black}{\texttt{>=}} \textcolor{Black}{t$_2$}\textcolor{Black}{\texttt{)}}\\
		\phantom{конец}\textcolor{Black}{\texttt{\{}}\\
		\phantom{конецмоимс}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\\
		\phantom{конецмоимс}\textcolor{Black}{\texttt{увелич}}\textcolor{Black}{\texttt{(}}\synt{v}\textcolor{Black}{\texttt{,}} \textcolor{Black}{t$_3$}\textcolor{Black}{\texttt{)}}\\
		\phantom{конец}\textcolor{Black}{\texttt{\}}}\\
		\textcolor{Black}{\texttt{\}}}\textcolor{Black}{\textbf{иначе}}\\
		\textcolor{Black}{\texttt{\{}}\\
		\phantom{конец}\synt{v} \textcolor{Black}{\texttt{:=}} \textcolor{Black}{t$_1$}\textcolor{Black}{;}\\
		\phantom{конец}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\\
		\phantom{конец}\textcolor{Black}{\textbf{пока}}\textcolor{Black}{\texttt{(}}\textcolor{Black}{t$_1$} \textcolor{Black}{\texttt{!=}} \textcolor{Black}{t$_2$}%
		\textcolor{Black}{\texttt{)}}\\
		\phantom{конец}\textcolor{Black}{\texttt{\{}}\\
		\phantom{конецмоимс}\rbo\snotion{описание} \sor \snotion{операторы}\rbc\kleene\\
		\phantom{конец}\textcolor{Black}{\texttt{\}}}\\
		\textcolor{Black}{\texttt{\}}}\\
		\textcolor{Black}{\texttt{\}}}
}}

\part{Стандартная библиотека}


%\chapter{Язык}
%    \section{Лексемы и форма описания синтаксиса}
%
%Синтаксис языка программирования Лиса описан как словесно, так и с помощью расширенных формул Бэкуса--Наура (РБНФ). В РБНФ формула состоит из двух частей: первая часть содержит имя определяемого понятия (в используемой здесь версии РБНФ оно выделяется зелёным цветом), а затем, после метасимвола \textcolor{Green}{$\to$}, идёт вторая часть, содержащая определение понятия. В данном описании кроме метасимвола \textcolor{Green}{$\to$} будут также использоваться следующие метасимволы:
%
%\textcolor{Green}{$|$} --- означает\ \glqq или\grqq;
%
%\textcolor{Green}{$\{\}$} --- содержимое этих скобок может повторяться любое число раз, в том числе и ни разу;
%
%\textcolor{Green}{$( )$} --- эти скобки группируют конструкции;
%
%\textcolor{Green}{$[ ]$} --- содержимое данных скобок является необязательным.
%
%Текст программы на языке Лиса состоит из лексем. В языке имеется четыре класса лексем:
%\begin{enumerate}
%    \item ключевые слова и идентификаторы;
%    \item числа;
%    \item знаки операций и разделители;
%    \item литёры и строки.
%\end{enumerate}
%Никакая лексема не может разбиваться на части пробельными символами (т.е. пробелами, табуляциями и концами строк) или комментариями. Опишем каждый класс лексем.
%        \subsection{Ключевые слова и идентификаторы}
%Идентификатор --- это последовательность русских и латинских букв, десятичных цифр и знаков подчёркивания. Идентификатор должен начинаться с буквы или со знака подчёркивания.
%Прописные и строчные буквы считаются различными. Идентификатор не может совпадать ни с каким ключевым словом. Ключевые слова языка записываются строчными буквами и в настоящем
%описании выделяются жирным шрифтом. Ниже приведён список ключевых слов:        
%
%
%К операциям с логическими значениями тесно примыкают тернарные операции \texttt{?:} и \texttt{?.:}. Поясним смысл операций \texttt{?:} и \texttt{?.:}.
%
%1) Операция \texttt{?:}. Выражение вида \texttt{S?A:B} эквивалентно следующей последовательности действий:
%{\renewcommand{\theenumi}{\asbuk{enumi}}
%\begin{enumerate}
%    \item вычислить логическое выражение \texttt{S}, и выражения \texttt{A} и \texttt{B};
%    \item
%если (\texttt{S=}\textbf{истина}) то\\
%\phantom{mm}выдать \texttt{A}\\
%иначе\\
%\phantom{mm}выдать \texttt{B}\\
%всё
%\end{enumerate}
%}
%
%\begin{Remark}
%Если в системе команд процессора имеется команда условной пересылки, то для вычислений в пункте б) \textbf{должна использоваться именно эта команда}.
%\end{Remark}
%
%2) Операция \texttt{?.:}. Выражение вида \texttt{S?.A:B} эквивалентно следующей последовательности действий:
%{\renewcommand{\theenumi}{\asbuk{enumi}}
%\begin{enumerate}
%    \item вычислить логическое выражение \texttt{S};
%    \item
%если (\texttt{S=}\textbf{истина}) то\\
%\phantom{mm}вычислить выражение \texttt{A} и выдать полученное значение\\
%иначе\\
%\phantom{mm}вычислить выражение \texttt{B} и выдать полученное значение\\
%всё
%\end{enumerate}
%}
%
%\begin{Remark}
%Здесь для вычислений в пункте б) \textbf{должна использоваться команда сравнения с последующим условным переходом}.
%\end{Remark}
%   
%\section{Операторы}
%
%
%
%
%    \subsection{Оператор выхода из цикла}
%
%Синтаксис оператора выхода из цикла:
%\begin{center}
%\textcolor{Green}{\syntax{\textcolor{Black}{\textbf{выход}} [\textcolor{Black}{\textbf{из}} \synt{имя_цикла}]}}
%\end{center}
%Этот оператор совершает выход из с цикла с именем \textcolor{Green}{\syntax{\synt{имя_цикла}}}, если оно указано. Если же нет, то производится выход из текущего цикла.
%
%    \subsection{Оператор возврата из функции}
%Оператор возврата из подпрограммы совершает выход из функции. Если тип возвращаемого функцией значения --- тип \textbf{ничего}, то выход из подпрограммы выполняется
%с помощью оператора возврата, имеющего вид \textbf{возврат}. Если же тип возвращаемого функцией значения не эквивалентен типу \textbf{ничего}, то возврат выполняется
%с помощью оператора возврата, имеющего вид \textbf{возврат} \textcolor{Green}{\syntax{\synt{выражение}}}, причём тип выражения должен быть совместим с типом
%возвращаемого функцией значения.
%         
%\chapter{Стандартная библиотека}
%    \section{Математические функции}
%    \section{Ввод-вывод}

\end{document}